changecom(/*,*/)dnl
#ifndef BENCHMARK_CONFIG_H
#define BENCHMARK_CONFIG_H
/**
 * This is an autogenerated header file, do NOT edit!
 * It is generated by the use of m4 macros.
 *
 * These are the benchmarks:
 * 1-1: linear array access
 * 1-2: linear array write
 * 1-3: random array access
 * 1-4: random array write
 * 2-1: mälardalen bsort 100
 * 2-2: mälardalen ns
 * 2-3: mälardalen matmult
 * 2-4: mälardalen fir
 * 3-1: sd-vbs disparity
 * 3-2: sd-vbs mser
 * 3-3: sd-vbs svm
 * 3-4: sd-vbs stitch
 *
 * The BENCH_CONFIG definition prescribes the specific benchmarks running
 * on the specific cores. If only one benchmark runs on multiple cores, the
 * NR_OF_CORES definition says on how many cores the benchmark is run.
 */
divert(`-1')
/* Define forloop for iteration within m4 */
/* forloop(var, from, to, stmt) - simple version, taken from GNU manual */
define(`forloop', `pushdef(`$1', `$2')_forloop($@)popdef(`$1')')
define(`_forloop',
`$4`'ifelse($1, `$3', `', `define(`$1', incr($1))$0($@)')')
divert`'dnl
/* Number of benchmarks series is currently 3  */
define(nr_of_benchmarks_series, 3)dnl
/* Maximum number of benchmarks per series is currently 4 */
define(nr_of_benchmarks, 4)dnl
/* Default configuration of series is '123' (but can be altered on the m4-cmdline) */
define(config_series, `321')dnl
/* Default configuration of benchmarks is '123' (but can be altered on the m4-cmdline) */
define(config_benchmarks, `123')dnl
/* Default number of PMUs is 4 (but can be altered on the m4-cmdline) */
define(nr_of_pmus, 4)dnl
/* Default event count configuration is '01' */
define(eventscore0, `01')dnl
define(bench_string_core_undef, `
#ifdef BENCH_STRING_CORE`$1'
#undef BENCH_STRING_CORE`$1'
#endif')dnl
define(bench_config_core_undef, `
#ifdef BENCH_CONFIG_CORE`$1'_`$2'_`$3'
#undef BENCH_CONFIG_CORE`$1'_`$2'_`$3'
#endif')dnl
define(bench_decl_core_undef, `
#ifdef BENCH_DECL_CORE`$1'
#undef BENCH_DECL_CORE`$1'
#endif')dnl
define(bench_init1_core_undef, `
#ifdef BENCH_INIT1_CORE`$1'
#undef BENCH_INIT1_CORE`$1'
#endif')dnl
define(bench_init2_core_undef, `
#ifdef BENCH_INIT2_CORE`$1'
#undef BENCH_INIT2_CORE`$1'
#endif')dnl
define(do_bench_core_undef, `
#ifdef DO_BENCH_CORE`$1'
#undef DO_BENCH_CORE`$1'
#endif')dnl
define(bench_cleanup_core_undef, `
#ifdef BENCH_CLEANUP_CORE`$1'
#undef BENCH_CLEANUP_CORE`$1'
#endif')dnl
define(pmu_event_core_undef, `
#ifdef PMU_EVENT_CORE`$1'_`$2'
#undef PMU_EVENT_CORE`$1'_`$2'
#endif')dnl
dnl
dnl Definition of macro_loop
dnl
dnl This macro will run a for loop from the first argument
dnl to the second argument. In each iteration the third argument
dnl is called as a macro, with the index of the for loop as
dnl the macro's argument.
define(macro_loop, `forloop(`i', `$1', `$2', `$3(i)')')dnl
dnl
dnl Definition of macro_doubleloop
dnl
dnl This macro will run a for loop from the first argument
dnl to the second argument. In each iteration the third and
dnl fourth argument are used as iterations for the inner for
dnl loop. In each iteration of the inner for loop, the fifth
dnl arugment is called as a macro, with the index of the inner
dnl for loop as the macro's argument.
define(macro_doubleloop, `forloop(`i', `$1', `$2',
                         `forloop(`j', `$3', `$4', `$5(i, j)')')')dnl
dnl
dnl Definition of macro_tripleloop
dnl
dnl This macro will run a for loop from the first argument
dnl to the second argument. In each iteration the third and
dnl fourth argument are used as iterations for the first inner
dnl for loop. In each iteration of the first inner for loop,
dnl the fifth and sixth arguments are used as iterations for the
dnl second inner loop. In each iteration of the second inner for
dnl loop, the seventh argument is called as a macro, with the
dnl index of the second inner for loop as the macro's argument.
define(macro_tripleloop, `forloop(`i', `$1', `$2',
                         `forloop(`j', `$3', `$4',
                         `forloop(`k', `$5', `$6', `$7(i, j, k)')')')')dnl

dnl *************************************
dnl BENCHMARK INPUTSIZE NAMES FOR DEFINES
dnl *************************************
dnl
dnl series nr 1: synthetic benchmarks
define(bench_inputsize_name1_1, `SYNBENCH_DATASIZE')dnl
define(bench_inputsize_name1_2, `SYNBENCH_DATASIZE')dnl
define(bench_inputsize_name1_3, `SYNBENCH_DATASIZE')dnl
define(bench_inputsize_name1_4, `SYNBENCH_DATASIZE')dnl
dnl series nr 2: Mälardalen
define(bench_inputsize_name2_1, `MALARDALEN_BSORT_INPUTSIZE')dnl
define(bench_inputsize_name2_2, `MALARDALEN_NS_INPUTSIZE')dnl
define(bench_inputsize_name2_3, `MALARDALEN_MATMULT_INPUTSIZE')dnl
define(bench_inputsize_name2_4, `MALARDALEN_FIR_INPUTSIZE')dnl
dnl series nr 2: SD-VBS
define(bench_inputsize_name3_1, `SDVBS_DISPARITY_INPUTSIZE')dnl
define(bench_inputsize_name3_2, `SDVBS_MSER_INPUTSIZE')dnl
define(bench_inputsize_name3_3, `SDVBS_SVM_INPUTSIZE')dnl
define(bench_inputsize_name3_4, `SDVBS_STITCH_INPUTSIZE')dnl
dnl
define(call_bench_inputsize_name, bench_inputsize_name$1_$2)dnl

dnl **************************************
dnl BENCHMARK NAMES FOR USAGE IN REPORTING
dnl **************************************
dnl
dnl series nr 1: synthetic benchmarks
define(bench_name1_1, linear_array_access)dnl
define(bench_name1_2, linear_array_write)dnl
define(bench_name1_3, random_array_access)dnl
define(bench_name1_4, random_array_write)dnl
dnl series nr 2: Mälardalen
define(bench_name2_1, malardalen_bsort100)dnl
define(bench_name2_2, malardalen_ns)dnl
define(bench_name2_3, malardalen_matmult)dnl
define(bench_name2_4, malardalen_fir)dnl
dnl series nr 2: SD-VBS
define(bench_name3_1, sdvbs_disparity)dnl
define(bench_name3_2, sdvbs_mser)dnl
define(bench_name3_3, sdvbs_svm)dnl
define(bench_name3_4, sdvbs_stitch)dnl
dnl
define(call_bench_name, bench_name$1_$2)dnl

dnl **********************************
dnl DECLARATION OF BENCHMARK VARIABLES
dnl **********************************
dnl
dnl series nr 1: synthetic benchmarks
define(bench_decl_1_1, `volatile bigstruct_t* mydata$1;')dnl
define(bench_decl_1_2, `volatile bigstruct_t* mydata$1;')dnl
define(bench_decl_1_3, `\
	volatile bigstruct_t* mydata$1;			\
	volatile int* myrandidx$1;
')dnl
define(bench_decl_1_4, `\
	volatile bigstruct_t* mydata$1;			\
	volatile int* myrandidx$1;
')dnl
dnl series nr 2: Mälardalen
define(bench_decl_2_1, `volatile int* Array$1;')dnl
define(bench_decl_2_2, `\
	int (*keys$1)[NS_ELEMS][NS_ELEMS][NS_ELEMS];	\
	int (*answer$1)[NS_ELEMS][NS_ELEMS][NS_ELEMS];
')dnl
define(bench_decl_2_3, `\
	matrix matA$1;						\
	matrix matB$1;						\
	matrix matC$1;
')dnl
define(bench_decl_2_4, `\
    long fir_int$1[FIR_COEFFSIZE]={\
0xfffffffe, 0x1, 0x4, 0x3, 0xfffffffe, 0xfffffffc, 0x2, 0x7, 0x0,			\
0xfffffff7, 0xfffffffc, 0xc, 0xb, 0xfffffff2, 0xffffffe6, 0xf, 0x59, 0x7f,	\
0x59, 0xf, 0xffffffe6, 0xfffffff2, 0xb, 0xc, 0xfffffffc, 0xfffffff7, 0x0,	\
0x7, 0x2, 0xfffffffc, 0xfffffffe, 0x3, 0x4, 0x1, 0xfffffffe, 0};			\
    long* in_data$1;														\
    long* output$1;
')dnl
dnl series nr 3: SD-VBS
define(bench_decl_3_1, `')dnl
define(bench_decl_3_2, `')dnl
define(bench_decl_3_3, `')dnl
define(bench_decl_3_4, `')dnl

dnl *************************************
dnl BENCHMARK INITIALIZATION 1 STATEMENTS
dnl *************************************
dnl
dnl series nr 1: synthetic benchmarks
define(bench_init1_1_1, `mydata$1 = new (HEAP_HIGH) bigstruct_t[INPUTSIZE_CORE$1];')dnl
define(bench_init1_1_2, `mydata$1 = new (HEAP_HIGH) bigstruct_t[INPUTSIZE_CORE$1];')dnl
define(bench_init1_1_3, `\
	mydata$1 = new (HEAP_HIGH) bigstruct_t[INPUTSIZE_CORE$1]; \
	myrandidx$1 = new (HEAP_HIGH) int[INPUTSIZE_CORE$1];
')dnl
define(bench_init1_1_4, `\
	mydata$1 = new (HEAP_HIGH) bigstruct_t[INPUTSIZE_CORE$1]; \
	myrandidx$1 = new (HEAP_HIGH) int[INPUTSIZE_CORE$1];
')dnl
dnl series nr 2: Mälardalen
define(bench_init1_2_1, `Array$1 = (volatile int*) new (HEAP_HIGH) int[INPUTSIZE_CORE$1];')dnl
define(bench_init1_2_2, `\
	/* nr of elements in 4-dim array */									\
	keys$1 = new (HEAP_HIGH) [INPUTSIZE_CORE$1][INPUTSIZE_CORE$1][INPUTSIZE_CORE$1];	\
	answer$1 = new (HEAP_HIGH) [INPUTSIZE_CORE$1][INPUTSIZE_CORE$1][INPUTSIZE_CORE$1];	\
	ns_Initialize(keys$1, answer$1);')dnl
define(bench_init1_2_3, `')dnl
define(bench_init1_2_4, `\
	in_data$1 = (long*) new (HEAP_HIGH) long[INPUTSIZE_CORE$1];			\
	output$1 = (long*) new (HEAP_HIGH) long[INPUTSIZE_CORE$1];
	')dnl
dnl series nr 3: SD-VBS
define(bench_init1_3_1, `\
	int width=INPUTSIZE_CORE$1, height=INPUTSIZE_CORE$1;		\
	int WIN_SZ=4, SHIFT=8;										\
	I2D* srcImage1 = iMallocHandle(width, height);				\
	I2D* srcImage2 = iMallocHandle(width, height);
')dnl
define(bench_init1_3_2, `\
	int width=INPUTSIZE_CORE$1, height=INPUTSIZE_CORE$1;		\
	int in_delta=2;											\
	I2D* srcImage = iMallocHandle(width, height);
')dnl
define(bench_init1_3_3, `\
	int svm_iter = 8;										\
    int svm_N = INPUTSIZE_CORE$1;							\
    int svm_Ntst = INPUTSIZE_CORE$1;						\
    F2D* svm_trn1 = fMallocHandle(svm_N, svm_N);			\
    F2D* svm_trn2 = fMallocHandle(svm_N, svm_N);			\
    F2D* svm_tst1 = fMallocHandle(svm_N, svm_N);			\
    F2D* svm_tst2 = fMallocHandle(svm_N, svm_N);
')dnl
define(bench_init1_3_4, `\
    int stitch_N = INPUTSIZE_CORE$1;						\
	I2D* Icur = iMallocHandle(stitch_N, stitch_N);
')dnl

dnl *************************************
dnl BENCHMARK INITIALIZATION 2 STATEMENTS
dnl *************************************
dnl
dnl series nr 1: synthetic benchmarks
define(bench_init2_1_1, `')dnl
define(bench_init2_1_2, `')dnl
define(bench_init2_1_3, `array_access_randomize(myrandidx$1, &rand);')dnl
define(bench_init2_1_4, `array_access_randomize(myrandidx$1, &rand);')dnl
dnl series nr 2: Mälardalen
define(bench_init2_2_1, `bsort100_Initialize(Array$1, &rand);')dnl
define(bench_init2_2_2, `')dnl
define(bench_init2_2_3, `\
	matmult_Initialize(matA$1);						\
	matmult_Initialize(matB$1);
')dnl
define(bench_init2_2_4, `\
	fir_Initialize(in_data$1);
')dnl
dnl series nr 3: SD-VBS
define(bench_init2_3_1, `\
	for (int `i'=0; `i'<(width*height); `i'++) { \
		srcImage1->data[`i'] = rand.GetNumber() % 256; \
		srcImage2->data[`i'] = rand.GetNumber() % 256; \
	}
')dnl
define(bench_init2_3_2, `\
	for (int `i'=0; `i'<(width*height); `i'++) {				\
		srcImage->data[`i'] = rand.GetNumber() % 256;			\
	}
')dnl
define(bench_init2_3_3, `\
	float r;													\
	for (int `i'=0; `i'<(svm_N*svm_N); `i'++) {				\
		r = (float) (rand.GetSmallFloat());					\
		svm_trn1->data[`i'] = r;								\
		r = (float) (rand.GetSmallFloat());					\
		svm_trn2->data[`i'] = r;								\
		r = (float) (rand.GetSmallFloat());					\
		svm_tst1->data[`i'] = r;								\
		r = (float) (rand.GetSmallFloat());					\
		svm_tst2->data[`i'] = r;								\
	}
')dnl
define(bench_init2_3_4, `\
	for (int `i'=0; `i'<(stitch_N*stitch_N); `i'++) {			\
		Icur->data[`i'] = rand.GetNumber() % 256;			\
	}
')dnl


dnl **********************************
dnl ACTUAL STATEMENT CALLING BENCHMARK
dnl **********************************
dnl
dnl series nr 1: synthetic benchmarks
define(do_bench1_1, array_access_linear(mydata$1);)dnl
define(do_bench1_2, array_write_linear(mydata$1);)dnl
define(do_bench1_3, array_access_random(mydata$1, myrandidx$1);)dnl
define(do_bench1_4, array_write_random(mydata$1, myrandidx$1);)dnl
dnl series nr 2: Mälardalen
define(do_bench2_1, bsort100_BubbleSort(Array$1);)dnl
define(do_bench2_2, ns_foo(keys$1, answer$1);)dnl
define(do_bench2_3, matmult_Multiply(matA$1, matB$1, matC$1);)dnl
define(do_bench2_4, fir_filter_int(in_data$1,output$1,INPUTSIZE_CORE$1,fir_int$1,FIR_COEFFSIZE-1,FIR_SCALE);)dnl
dnl series nr 3: SD-VBS
define(do_bench3_1, getDisparity(srcImage1, srcImage2, WIN_SZ, SHIFT);)dnl
define(do_bench3_2, mser(srcImage, in_delta);)dnl
define(do_bench3_3, svm_wrapper(svm_trn1, svm_tst1, svm_trn2, svm_tst2, svm_iter, svm_N, svm_Ntst);)dnl
define(do_bench3_4, stitch_wrapper(Icur);)dnl


dnl ******************************
dnl CLEANUP OF BENCHMARK VARIABLES
dnl ******************************
dnl
dnl series nr 1: synthetic benchmarks
define(bench_cleanup_1_1, `free((void*) mydata$1);')dnl
define(bench_cleanup_1_2, `free((void*) mydata$1);')dnl
define(bench_cleanup_1_3, `\
	free((void*) mydata$1);						\
	free((void*) myrandidx$1);
')dnl
define(bench_cleanup_1_4, `\
	free((void*) mydata$1);						\
	free((void*) myrandidx$1);
')dnl
dnl series nr 2: Mälardalen
define(bench_cleanup_2_1, `free((void*) Array$1);')dnl
define(bench_cleanup_2_2, `')dnl
define(bench_cleanup_2_3, `')dnl
define(bench_cleanup_2_4, `')dnl
dnl series nr 3: SD-VBS
define(bench_cleanup_3_1, `')dnl
define(bench_cleanup_3_2, `')dnl
define(bench_cleanup_3_3, `')dnl
define(bench_cleanup_3_4, `')dnl


define(call_bench_decl, bench_decl_$1_$2($3))dnl
define(call_bench_init1, bench_init1_$1_$2($3))dnl
define(call_bench_init2, bench_init2_$1_$2($3))dnl
define(call_do_bench, do_bench$1_$2($3))dnl
define(call_bench_cleanup, bench_cleanup_$1_$2($3))dnl

/**
 * Macro for generation of the defines that describe the
 * configuration of the cores and specific benchmarks running
 * on them.
 *  (e.g. BENCH_CONFIG_CORE0_2 => Core 0 runs 2nd benchmark)
 */
define(bench_config_core_def, `
#define BENCH_CONFIG_CORE`$1'_`'substr(config_series, $1, 1)`_'substr(config_benchmarks, $1, 1)')dnl
dnl
define(bench_string_core_def, `
#define BENCH_STRING_CORE`$1' "benchmark: call_bench_name(substr(config_series, $1, 1), substr(config_benchmarks, $1, 1))"')dnl
define(bench_string_core_empty_def, `
#define BENCH_STRING_CORE`$1' ""')dnl
dnl

define(bench_decl_core_def, `
#define BENCH_DECL_CORE`$1' call_bench_decl(substr(config_series, $1, 1), substr(config_benchmarks, $1, 1), `$1')')dnl
define(bench_decl_core_empty_def, `
#define BENCH_DECL_CORE`$1' $2')dnl

define(bench_init1_core_def, `
#define BENCH_INIT1_CORE`$1' call_bench_init1(substr(config_series, $1, 1), substr(config_benchmarks, $1, 1), `$1')')dnl
define(bench_init1_core_empty_def, `
#define BENCH_INIT1_CORE`$1' $2')dnl

define(bench_init2_core_def, `
#define BENCH_INIT2_CORE`$1' call_bench_init2(substr(config_series, $1, 1), substr(config_benchmarks, $1, 1), `$1')')dnl
define(bench_init2_core_empty_def, `
#define BENCH_INIT2_CORE`$1' $2')dnl

define(do_bench_core_def, `
#define DO_BENCH_CORE`$1' call_do_bench(substr(config_series, $1, 1), substr(config_benchmarks, $1, 1), `$1')')dnl
define(do_bench_core_empty_def, `
#define DO_BENCH_CORE`$1' $2')dnl

define(bench_cleanup_core_def, `
#define BENCH_CLEANUP_CORE`$1' call_bench_cleanup(substr(config_series, $1, 1), substr(config_benchmarks, $1, 1), `$1')')dnl
define(bench_cleanup_core_empty_def, `
#define BENCH_CLEANUP_CORE`$1' $2')dnl

dnl
define(pmu_event0, `(PMU_L1D_CACHE_REFILL)')dnl
define(pmu_event1, `(PMU_L1D_CACHE)')dnl
define(pmu_event2, `(PMU_L1D_TLB_REFILL)')dnl
define(pmu_event3, `(PMU_MEM_ACCESS)')dnl
define(pmu_event4, `(PMU_L1D_CACHE_WB)')dnl
define(pmu_event5, `(PMU_L2D_CACHE)')dnl
define(pmu_event6, `(PMU_L2D_CACHE_REFILL)')dnl
define(pmu_event7, `(PMU_L1D_CACHE_WB)')dnl
define(pmu_event8, `(PMU_BUS_ACCESS)')dnl
define(pmu_event9, `(PMU_BUS_CYCLES)')dnl
define(call_pmu_event, pmu_event$1)dnl
dnl
divert(0)dnl
dnl


macro_loop(0, 3, `bench_string_core_undef')dnl
macro_loop(0, 3, `bench_decl_core_undef')dnl
macro_loop(0, 3, `bench_init1_core_undef')dnl
macro_loop(0, 3, `bench_init2_core_undef')dnl
macro_loop(0, 3, `do_bench_core_undef')dnl
macro_loop(0, 3, `bench_cleanup_core_undef')dnl
macro_tripleloop(0, 3, 1, 3, 1, nr_of_benchmarks, `bench_config_core_undef')dnl
macro_doubleloop(0, 3, 1, nr_of_pmus, `pmu_event_core_undef')dnl


dnl Define all benchmark inputsizes with a default value, to make
dnl sure that all inputsizes have been defined.
dnl The specific needed inputsizes that are given as parameters to
dnl this script will be redefined below.
define(bench_inputsize_name_init_def, `
#ifndef call_bench_inputsize_name($1, $2)
#define call_bench_inputsize_name($1, $2) `100'
#endif
')dnl
macro_doubleloop(1, 3, 1, nr_of_benchmarks, `bench_inputsize_name_init_def')dnl


dnl Benchmark specific configuration parameters
dnl
dnl Size of input for all cores, if inputsize was defined as a parameter
dnl to this script this size will be used. Otherwise the default size of 50
dnl will be used.
define(inputsize_template, `
#ifdef INPUTSIZE_CORE$1
#undef INPUTSIZE_CORE$1
#endif
#define INPUTSIZE_CORE$1 $2
')dnl
define(call_inputsize_template, `
ifdef(`inputsize_core$1', inputsize_template($1, `inputsize_core$1'), `inputsize_template($1, 50)')
')dnl
macro_loop(0, 3, `call_inputsize_template')dnl


dnl For each benchmark that runs on a specifi core, define the corresponding
dnl macro for the inputsize. The inputsize is specified per core, which is
dnl tied to the specific benchmark with the following macro loop.
define(inputsize_name_core_def, `
#ifdef call_bench_inputsize_name(substr(config_series, $1, 1), substr(config_benchmarks, $1, 1))
#undef call_bench_inputsize_name(substr(config_series, $1, 1), substr(config_benchmarks, $1, 1))
#endif
#define call_bench_inputsize_name(substr(config_series, $1, 1), substr(config_benchmarks, $1, 1)) INPUTSIZE_CORE$1')dnl
macro_loop(0, eval(len(config_benchmarks) - 1), `inputsize_name_core_def')dnl


/* Configuration of benchmarks */
macro_loop(0, eval(len(config_benchmarks) - 1), `bench_config_core_def')dnl
dnl
macro_loop(0, eval(len(config_benchmarks) - 1), `bench_string_core_def')dnl
ifelse(len(config_benchmarks), 4, `', `macro_loop(len(config_benchmarks), 3, `bench_string_core_empty_def')')dnl
dnl
macro_loop(0, eval(len(config_benchmarks) - 1), `bench_decl_core_def')dnl
ifelse(len(config_benchmarks), 4, `', `macro_loop(len(config_benchmarks), 3, `bench_decl_core_empty_def')')dnl
dnl
macro_loop(0, eval(len(config_benchmarks) - 1), `bench_init1_core_def')dnl
ifelse(len(config_benchmarks), 4, `', `macro_loop(len(config_benchmarks), 3, `bench_init1_core_empty_def')')dnl
dnl
macro_loop(0, eval(len(config_benchmarks) - 1), `bench_init2_core_def')dnl
ifelse(len(config_benchmarks), 4, `', `macro_loop(len(config_benchmarks), 3, `bench_init2_core_empty_def')')dnl
dnl
macro_loop(0, eval(len(config_benchmarks) - 1), `do_bench_core_def')dnl
ifelse(len(config_benchmarks), 4, `', `macro_loop(len(config_benchmarks), 3, `do_bench_core_empty_def')')dnl
dnl
macro_loop(0, eval(len(config_benchmarks) - 1), `bench_cleanup_core_def')dnl
ifelse(len(config_benchmarks), 4, `', `macro_loop(len(config_benchmarks), 3, `bench_cleanup_core_empty_def')')dnl
dnl


#ifdef CONFIG_SERIES_STRING
#undef CONFIG_SERIES_STRING
#endif
#define CONFIG_SERIES_STRING "`config_series': 'config_series'"dnl


#ifdef CONFIG_BENCH_STRING
#undef CONFIG_BENCH_STRING
#endif
#define CONFIG_BENCH_STRING "`config_benchmarks': 'config_benchmarks'"dnl

define(nr_of_cores, 4)
#ifdef NR_OF_CORES
#undef NR_OF_CORES
#endif
#define NR_OF_CORES len(config_benchmarks)
dnl

/* The PMU event count configuration */dnl
define(pmu_core_def, `
#define PMU_EVENT_CORE`$1'_`'eval($2+1)`' `'call_pmu_event(substr(pmu_core$1, $2, 1))')dnl
dnl
define(pmu_core_def0, `pmu_core_def(0, $1)')dnl
define(pmu_core_def1, `pmu_core_def(1, $1)')dnl
define(pmu_core_def2, `pmu_core_def(2, $1)')dnl
define(pmu_core_def3, `pmu_core_def(3, $1)')dnl
dnl
ifdef(`pmu_core0', macro_loop(0, eval(len(pmu_core0) - 1), `pmu_core_def0'))dnl
ifdef(`pmu_core1', macro_loop(0, eval(len(pmu_core1) - 1), `pmu_core_def1'))dnl
ifdef(`pmu_core2', macro_loop(0, eval(len(pmu_core2) - 1), `pmu_core_def2'))dnl
ifdef(`pmu_core3', macro_loop(0, eval(len(pmu_core3) - 1), `pmu_core_def3'))dnl

dnl maybe use a label that is used by the data visualization scripts
ifdef(`exp_label', `', `define(exp_label, `default')')
#ifdef EXP_LABEL
#undef EXP_LABEL
#define EXP_LABEL "exp_label"
#endif

dnl maybe define the tick rate in Hz
define(delay_step_countdown_template, `
#ifdef DELAY_STEP_COUNTDOWN
#undef DELAY_STEP_COUNTDOWN
#endif
#define DELAY_STEP_COUNTDOWN $1
')dnl
ifdef(`delay_step_countdown', `delay_step_countdown_template(delay_step_countdown)', `')

dnl maybe enable the MMU
define(mmu_enable_def, `
#ifndef MMU_ENABLE
#define MMU_ENABLE
#endif
')dnl
ifdef(`mmu_enable', mmu_enable_def, `')dnl

dnl maybe enable screen
define(screen_enable_def, `
#ifndef SCREEN_ENABLE
#define SCREEN_ENABLE
#endif
')dnl
ifdef(`screen_enable', screen_enable_def, `')dnl

dnl maybe enable debug info
define(debug_enable_def, `
#ifndef DEBUG_ENABLE
#define DEBUG_ENABLE
#endif
')dnl
ifdef(`debug_enable', debug_enable_def, `')dnl

dnl Optionally report the number of cycles spent while busy
dnl waiting a specific number of countdown counts. The countdown
dnl function is used for causing co-runners to delay their execution.
define(report_cycles_countdown_template, `
#define REPORT_CYCLES_COUNTDOWN
')dnl
ifdef(`report_cycles_countdown', report_cycles_countdown_template, `')dnl

#endif /* ~BENCHMARK_CONFIG_H */
